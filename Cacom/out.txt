   Compiling cacom v0.1.0 (/home/gregofi1/repos/camel/Cacom)
error: failed to run custom build command for `cacom v0.1.0 (/home/gregofi1/repos/camel/Cacom)`

Caused by:
  process didn't exit successfully: `/home/gregofi1/repos/camel/Cacom/target/debug/build/cacom-15054957b31fe571/build-script-build` (exit status: 1)
  --- stdout
  processing file `/home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop`
  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `AND` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ASSIGN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CLASS` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `DIVIDE`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>   ╷ TermOp Term
      ├─Term────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> TermOp Term
      ├─Unary<UnaryOp, Primary>─────┤           │
      ├─Term────────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `DOT`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ DOT String
      ├─Term────────────────────────┤          │
      ├─LeftAssoc<TermOp, Term>─────┤          │
      ├─Factor──────────────────────┤          │
      ├─LeftAssoc<ExprOp, Factor>───┤          │
      ├─AExpr───────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─┤          │
      ├─Expr────────────────────────┘          │
      └─MemberRead─────────────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> DOT String
      ├─Unary<UnaryOp, Primary>─────┤          │
      ├─Term────────────────────────┤          │
      ├─LeftAssoc<TermOp, Term>─────┤          │
      ├─Factor──────────────────────┤          │
      ├─LeftAssoc<ExprOp, Factor>───┤          │
      ├─AExpr───────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─┤          │
      ├─Expr────────────────────────┘          │
      └─MemberRead─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `EQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `GREATER`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `GREATEREQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LBRACKET` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `LESS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `LESSEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LET` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `MINUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>     ╷ ExprOp Factor
      ├─Term──────────────────────┤             │
      ├─LeftAssoc<TermOp, Term>───┤             │
      ├─Factor────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> ExprOp Factor
      ├─Unary<UnaryOp, Primary>─────┤             │
      ├─Term────────────────────────┤             │
      ├─LeftAssoc<TermOp, Term>─────┤             │
      ├─Factor──────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>───┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `MODULO`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>   ╷ TermOp Term
      ├─Term────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> TermOp Term
      ├─Unary<UnaryOp, Primary>─────┤           │
      ├─Term────────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `MULTIPLY`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>   ╷ TermOp Term
      ├─Term────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> TermOp Term
      ├─Unary<UnaryOp, Primary>─────┤           │
      ├─Term────────────────────────┤           │
      ├─LeftAssoc<TermOp, Term>─────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `NEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>       ╷ LogicalOp AExpr
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> LogicalOp AExpr
      ├─Unary<UnaryOp, Primary>─────┤               │
      ├─Term────────────────────────┤               │
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `OR` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      UnaryOp Unary<UnaryOp, Primary>
    At that point, if the next token is a `PLUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 1 token(s) from the stack and produce a `Term`. This might then yield a parse tree like
      Unary<UnaryOp, Primary>     ╷ ExprOp Factor
      ├─Term──────────────────────┤             │
      ├─LeftAssoc<TermOp, Term>───┤             │
      ├─Factor────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30, which would consume the top 2 token(s) from the stack and produce a `Unary<UnaryOp, Primary>`. This might then yield a parse tree like
      UnaryOp Unary<UnaryOp, Primary> ExprOp Factor
      ├─Unary<UnaryOp, Primary>─────┤             │
      ├─Term────────────────────────┤             │
      ├─LeftAssoc<TermOp, Term>─────┤             │
      ├─Factor──────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>───┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RBRACKET` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RPAREN` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:161:8: 161:30: Conflict detected

      when in this state:
    Term = Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = UnaryOp Unary<UnaryOp, Primary> (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EOF` we can reduce to a `Term` but we can also reduce to a `Unary<UnaryOp, Primary>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:84:5: 87:5: Conflict detected

      when in this state:
    Block = CURLYBOPEN Expr (*) CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `Statement` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:84:5: 87:5: Conflict detected

      when in this state:
    Block = CURLYBOPEN Expr (*) CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Statement` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:261:5: 265:0: Conflict detected

      when in this state:
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = RETURN Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Return` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `AND` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ASSIGN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CLASS` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DIVIDE` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EQ` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `GREATER` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `GREATEREQ` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LBRACKET` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LESS` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LESSEQ` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LET` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MINUS` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MODULO` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MULTIPLY` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NEQ` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `OR` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `PLUS` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RBRACKET` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RPAREN` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:276:13: 276:20: Conflict detected

      when in this state:
    (<TopLevelExpression> SEMICOLON)+ = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    SeparatedLeastOne<TopLevelExpression, SEMICOLON> = (<TopLevelExpression> SEMICOLON)+ TopLevelExpression SEMICOLON (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EOF` we can reduce to a `(<TopLevelExpression> SEMICOLON)+` but we can also reduce to a `SeparatedLeastOne<TopLevelExpression, SEMICOLON>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:102:5: 106:0: Conflict detected

      when in this state:
    Assignment = Identifier ASSIGN Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Assignment` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MINUS` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ (*) Expr COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = Expr (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = Expr (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `AND` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ASSIGN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CLASS` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DIVIDE` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `DOT`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ DOT String
      ├─LeftAssoc<ExprOp, Factor>───┤          │
      ├─AExpr───────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─┤          │
      ├─Expr────────────────────────┘          │
      └─MemberRead─────────────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor DOT String
      ├─LeftAssoc<ExprOp, Factor>───────────┤          │
      ├─AExpr───────────────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┤          │
      ├─Expr────────────────────────────────┘          │
      └─MemberRead─────────────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `EQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `GREATER`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `GREATEREQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LBRACKET` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `LESS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `LESSEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LET` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `MINUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                      ╷ ExprOp Factor
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor ExprOp Factor
      ├─LeftAssoc<ExprOp, Factor>───────────┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MODULO` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MULTIPLY` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `NEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                        ╷ LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor LogicalOp AExpr
      ├─LeftAssoc<ExprOp, Factor>───────────┤               │
      ├─AExpr───────────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `OR` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<ExprOp, Factor> ExprOp Factor
    At that point, if the next token is a `PLUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      Factor                      ╷ ExprOp Factor
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<ExprOp, Factor>`. This might then yield a parse tree like
      LeftAssoc<ExprOp, Factor> ExprOp Factor ExprOp Factor
      ├─LeftAssoc<ExprOp, Factor>───────────┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RBRACKET` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RPAREN` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:146:9: 146:33: Conflict detected

      when in this state:
    LeftAssoc<ExprOp, Factor> = Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = LeftAssoc<ExprOp, Factor> ExprOp Factor (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EOF` we can reduce to a `LeftAssoc<ExprOp, Factor>` but we can also reduce to a `LeftAssoc<ExprOp, Factor>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `AND` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ASSIGN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CLASS` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DIVIDE` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `DOT`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ DOT String
      ├─LeftAssoc<LogicalOp, AExpr>─┤          │
      ├─Expr────────────────────────┘          │
      └─MemberRead─────────────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr DOT String
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┤          │
      ├─Expr────────────────────────────────────┘          │
      └─MemberRead─────────────────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `EQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `GREATER`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `GREATEREQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LBRACKET` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `LESS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `LESSEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LET` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MINUS` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MODULO` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MULTIPLY` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr
    At that point, if the next token is a `NEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      AExpr                         ╷ LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<LogicalOp, AExpr>`. This might then yield a parse tree like
      LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr LogicalOp AExpr
      ├─LeftAssoc<LogicalOp, AExpr>─────────────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `OR` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `PLUS` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RBRACKET` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RPAREN` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:135:8: 135:34: Conflict detected

      when in this state:
    LeftAssoc<LogicalOp, AExpr> = AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EOF` we can reduce to a `LeftAssoc<LogicalOp, AExpr>` but we can also reduce to a `LeftAssoc<LogicalOp, AExpr>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `AND` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ASSIGN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CLASS` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `DIVIDE`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term TermOp Term
      ├─LeftAssoc<TermOp, Term>─────────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                      ╷ TermOp Term
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `DOT`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term DOT String
      ├─LeftAssoc<TermOp, Term>─────────┤          │
      ├─Factor──────────────────────────┤          │
      ├─LeftAssoc<ExprOp, Factor>───────┤          │
      ├─AExpr───────────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─────┤          │
      ├─Expr────────────────────────────┘          │
      └─MemberRead─────────────────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ DOT String
      ├─LeftAssoc<TermOp, Term>─────┤          │
      ├─Factor──────────────────────┤          │
      ├─LeftAssoc<ExprOp, Factor>───┤          │
      ├─AExpr───────────────────────┤          │
      ├─LeftAssoc<LogicalOp, AExpr>─┤          │
      ├─Expr────────────────────────┘          │
      └─MemberRead─────────────────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `EQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `GREATER`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `GREATEREQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LBRACKET` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `LESS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `LESSEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LET` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `MINUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term ExprOp Factor
      ├─LeftAssoc<TermOp, Term>─────────┤             │
      ├─Factor──────────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>───────┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                        ╷ ExprOp Factor
      ├─LeftAssoc<TermOp, Term>───┤             │
      ├─Factor────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `MODULO`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term TermOp Term
      ├─LeftAssoc<TermOp, Term>─────────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                      ╷ TermOp Term
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `MULTIPLY`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term TermOp Term
      ├─LeftAssoc<TermOp, Term>─────────┘           │
      └─LeftAssoc<TermOp, Term>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                      ╷ TermOp Term
      ├─LeftAssoc<TermOp, Term>─┘           │
      └─LeftAssoc<TermOp, Term>─────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `NEQ`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────────┤               │
      ├─Factor──────────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───────┤               │
      ├─AExpr───────────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─────┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                          ╷ LogicalOp AExpr
      ├─LeftAssoc<TermOp, Term>─────┤               │
      ├─Factor──────────────────────┤               │
      ├─LeftAssoc<ExprOp, Factor>───┤               │
      ├─AExpr───────────────────────┤               │
      ├─LeftAssoc<LogicalOp, AExpr>─┘               │
      └─LeftAssoc<LogicalOp, AExpr>─────────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `OR` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Local ambiguity detected

    The problem arises after having observed the following symbols in the input:
      LeftAssoc<TermOp, Term> TermOp Term
    At that point, if the next token is a `PLUS`, then the parser can proceed in two different ways.

    First, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 3 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      LeftAssoc<TermOp, Term> TermOp Term ExprOp Factor
      ├─LeftAssoc<TermOp, Term>─────────┤             │
      ├─Factor──────────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>───────┘             │
      └─LeftAssoc<ExprOp, Factor>─────────────────────┘

    Alternatively, the parser could execute the production at /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32, which would consume the top 1 token(s) from the stack and produce a `LeftAssoc<TermOp, Term>`. This might then yield a parse tree like
      Term                        ╷ ExprOp Factor
      ├─LeftAssoc<TermOp, Term>───┤             │
      ├─Factor────────────────────┤             │
      ├─LeftAssoc<ExprOp, Factor>─┘             │
      └─LeftAssoc<ExprOp, Factor>───────────────┘

    See the LALRPOP manual for advice on making your grammar LR(1).

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RBRACKET` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RPAREN` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:153:10: 153:32: Conflict detected

      when in this state:
    LeftAssoc<TermOp, Term> = LeftAssoc<TermOp, Term> TermOp Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = Term (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `EOF` we can reduce to a `LeftAssoc<TermOp, Term>` but we can also reduce to a `LeftAssoc<TermOp, Term>`

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:249:14: 249:41: Conflict detected

      when in this state:
    (<Identifier> COMMA)+ = (*) (<Identifier> COMMA)+ Identifier COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Identifier> COMMA)+ = (*) Identifier COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN (*) Parameters RPAREN CURLYBOPEN Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Parameters = (*) Separated<Identifier, COMMA> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) (<Identifier> COMMA)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) (<Identifier> COMMA)+ Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Identifier, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:84:5: 87:5: Conflict detected

      when in this state:
    Block = CURLYBOPEN (<Statement> SEMICOLON)+ Expr (*) CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBCLOSE` we can reduce to a `Statement` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:84:5: 87:5: Conflict detected

      when in this state:
    Block = CURLYBOPEN (<Statement> SEMICOLON)+ Expr (*) CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Statement` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:249:14: 249:41: Conflict detected

      when in this state:
    (<Identifier> COMMA)+ = (*) (<Identifier> COMMA)+ Identifier COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Identifier> COMMA)+ = (*) Identifier COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = DEF Identifier LPAREN (*) Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Parameters = (*) Separated<Identifier, COMMA> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) (<Identifier> COMMA)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) (<Identifier> COMMA)+ Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Identifier, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:252:5: 258:0: Conflict detected

      when in this state:
    Conditional = IF Expr Block (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = IF Expr Block (*) ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `ELSE` we can reduce to a `Conditional` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ Expr (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:213:13: 213:34: Conflict detected

      when in this state:
    (<Expr> COMMA)+ = (<Expr> COMMA)+ Expr (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Expr, COMMA> = (<Expr> COMMA)+ Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `Separated<Expr, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:249:14: 249:41: Conflict detected

      when in this state:
    (<Identifier> COMMA)+ = (<Identifier> COMMA)+ (*) Identifier COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (<Identifier> COMMA)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (<Identifier> COMMA)+ (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Identifier, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:249:14: 249:41: Conflict detected

      when in this state:
    (<Identifier> COMMA)+ = Identifier (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = Identifier (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `Separated<Identifier, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:109:5: 112:5: Conflict detected

      when in this state:
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = VAL Identifier ASSIGN Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `VarDecl` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:113:5: 117:0: Conflict detected

      when in this state:
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = VAR Identifier ASSIGN Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `VarDecl` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:249:14: 249:41: Conflict detected

      when in this state:
    (<Identifier> COMMA)+ = (<Identifier> COMMA)+ Identifier (*) COMMA [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Identifier, COMMA> = (<Identifier> COMMA)+ Identifier (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `COMMA` we can reduce to a `Separated<Identifier, COMMA>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MINUS` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (*) (<Statement> SEMICOLON)+ Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    (<Statement> SEMICOLON)+ = (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    ClassDecl = CLASS Identifier LPAREN Parameters RPAREN CURLYBOPEN (*) Statements CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) (<Statement> SEMICOLON)+ Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statements = (*) Separated<Statement, SEMICOLON> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `CURLYBOPEN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DEF` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `FALSE` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IDENTIFIER` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `IF` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `LPAREN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `MINUS` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `NUMBER` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `RETURN` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `STRING_LITERAL` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `TRUE` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAL` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ (*) Statement SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    AExpr = (*) LeftAssoc<ExprOp, Factor> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Assignment = (*) Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN (<Statement> SEMICOLON)+ CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN Expr CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Block = (*) CURLYBOPEN CURLYBCLOSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Call = (*) Identifier LPAREN Arguments RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Conditional = (*) IF Expr Block ELSE Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Expr = (*) LeftAssoc<LogicalOp, AExpr> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Factor = (*) LeftAssoc<TermOp, Term> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    FunDecl = (*) DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Identifier = (*) IDENTIFIER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<ExprOp, Factor> = (*) LeftAssoc<ExprOp, Factor> ExprOp Factor [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<LogicalOp, AExpr> = (*) LeftAssoc<LogicalOp, AExpr> LogicalOp AExpr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) LeftAssoc<TermOp, Term> TermOp Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    LeftAssoc<TermOp, Term> = (*) Term [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = (*) Expr DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Number = (*) NUMBER [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Block [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Call [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Conditional [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Identifier [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) MemberRead [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) Number [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) FALSE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) LPAREN Expr RPAREN [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Primary = (*) TRUE [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Return = (*) RETURN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ (*) Statement [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Assignment [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) FunDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) Return [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Statement = (*) VarDecl [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    String = (*) STRING_LITERAL [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Term = (*) Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) Primary [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Unary<UnaryOp, Primary> = (*) UnaryOp Unary<UnaryOp, Primary> [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    UnaryOp = (*) MINUS [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAL Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    VarDecl = (*) VAR Identifier ASSIGN Expr [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `VAR` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = Statement (*) SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = Statement (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:243:5: 247:0: Conflict detected

      when in this state:
    FunDecl = DEF Identifier LPAREN Parameters RPAREN ASSIGN Expr (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    MemberRead = Expr (*) DOT String [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `DOT` we can reduce to a `FunDecl` but we can also shift

  /home/gregofi1/repos/camel/Cacom/src/grammar.lalrpop:240:14: 240:44: Conflict detected

      when in this state:
    (<Statement> SEMICOLON)+ = (<Statement> SEMICOLON)+ Statement (*) SEMICOLON [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]
    Separated<Statement, SEMICOLON> = (<Statement> SEMICOLON)+ Statement (*) [AND, ASSIGN, CLASS, COMMA, CURLYBCLOSE, CURLYBOPEN, DEF, DIVIDE, DOT, ELSE, EQ, FALSE, GREATER, GREATEREQ, IDENTIFIER, IF, IN, LBRACKET, LESS, LESSEQ, LET, LPAREN, MINUS, MODULO, MULTIPLY, NEQ, NUMBER, OR, PLUS, RBRACKET, RETURN, RPAREN, SEMICOLON, STRING_LITERAL, TRUE, VAL, VAR, EOF]

    and looking at a token `SEMICOLON` we can reduce to a `Separated<Statement, SEMICOLON>` but we can also shift
