use crate::ast::{AST, Opcode, IntoBoxed};
use crate::grammar::AST::NoneVal;
use std::collections::VecDeque;
use std::str::FromStr;

grammar;

// Lexer
match {
    // Comments, those we ignore
    r"\s*" => { },
    r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/|(//.*)" => { },

    // keywords
    ";" => SEMICOLON,
    "{" => CURLYBOPEN,
    "}" => CURLYBCLOSE,
    "||" => OR,
    "&&" => AND,
    "!=" => NEQ,
    "==" => EQ,
    "="  => ASSIGN,
    ">"  => GREATER,
    "<"  => LESS,
    ">=" => GREATEREQ,
    "<=" => LESSEQ,
    "*"  => MULTIPLY,
    "/"  => DIVIDE,
    "%"  => MODULE,
    "+"  => PLUS,
    "-" => MINUS,
    "if" => IF,
    "else" => ELSE,
    "(" => LPAREN,
    ")" => RPAREN,
    "let" => LET,
    "in" => IN,
    "print" => PRINT,
    "[" => RBRACKET,
    "]" => LBRACKET,
    "true" => TRUE,
    "false" => FALSE,
    "def" => DEF,
    "," => COMMA,

    r"[_A-Za-z][_A-Za-z0-9]*" => IDENTIFIER,
    r"[-]?[0-9]+" => NUMBER,
    // TODO FLOATS
    r#""([^\\"]|\\[~ntr\\"])*""# => STRING_LITERAL,
}

pub TopLevel: AST = {
    <toplevel: TopLevelExpressions> => AST::Top(toplevel.into_boxed()),
                                    => AST::Top(vec![NoneVal.into_boxed()]),
}

TopLevelExpressions: Vec<AST> = {
    <first: TopLevelExpression> <others: (SEMICOLON <TopLevelExpression>)*> SEMICOLON? => {
        let mut all = VecDeque::from(others);
        all.push_front(first);
        Vec::from(all)
    }
}

// FIXME: Currently possible to write something like (1 + def foo...)
TopLevelExpression: AST = {
    AExpr => <>,
    FunDecl => <>,
    Block => <>,
}

Expressions: Vec<AST> = {
    <first: Expression> <others: (SEMICOLON <Expression>)*> SEMICOLON? => {
        let mut all = VecDeque::from(others);
        all.push_front(first);
        Vec::from(all)
    }
}

Expression: AST = {
    AExpr => <>,
    Block => <>,
}

AExpr: AST = {
    <left:AExpr> <op:ExprOp> <right:Factor> => AST::Operator{op: op, arguments: vec![Box::new(left), Box::new(right)]},
    Factor,
}

Factor: AST = {
    <left:Factor> <op:TermOp> <right:Term> => AST::Operator{op: op, arguments: vec![Box::new(left), Box::new(right)]},
    Term,
}

ExprOp: Opcode = {
    PLUS => Opcode::Add,
    MINUS => Opcode::Sub,
}

TermOp: Opcode = {
    MULTIPLY => Opcode::Mul,
    DIVIDE => Opcode::Div,
}

Term: AST = {
    // TODO: floats
    Number => <>,
    LPAREN <AExpr> RPAREN,
}

Number: AST = {
    NUMBER => AST::Integer(i32::from_str(<>).unwrap()),
}

Block: AST = {
    CURLYBOPEN <expressions: Expressions> CURLYBCLOSE => AST::Block(expressions.into_boxed()),
    CURLYBOPEN CURLYBCLOSE => AST::NoneVal,
}

FunDecl: AST = {
    DEF <name: Identifier> <parameters: Parameters> ASSIGN <body: Expression> => {
        AST::Function{name, parameters, body: body.into_boxed()}
    }
}

Identifier: String = IDENTIFIER => <>.to_string();

Parameters: Vec<String> = {
    LPAREN <elements: (<Identifier> COMMA)*> <element: Identifier?> RPAREN =>
        match element {
            None => elements,
            Some(e) => { let mut elements = elements; elements.push(e); elements }
        }
}
