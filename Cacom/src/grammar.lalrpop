// The lexer and some of the grammar rules were inspired
// by Konrad Siek FML Language intepreter, thanks Konrad!
// https://github.com/kondziu

use crate::ast::{AST, Opcode, Expr};
use std::collections::VecDeque;
use std::str::FromStr;

grammar;

// Lexer
match {
    // Comments, those we ignore
    r"\s*" => { },
    r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/|(//.*)" => { },

    // keywords
    ";" => SEMICOLON,
    "{" => CURLYBOPEN,
    "}" => CURLYBCLOSE,
    "||" => OR,
    "&&" => AND,
    "!=" => NEQ,
    "==" => EQ,
    "="  => ASSIGN,
    ">"  => GREATER,
    "<"  => LESS,
    ">=" => GREATEREQ,
    "<=" => LESSEQ,
    "*"  => MULTIPLY,
    "/"  => DIVIDE,
    "%"  => MODULE,
    "+"  => PLUS,
    "-" => MINUS,
    "if" => IF,
    "else" => ELSE,
    "(" => LPAREN,
    ")" => RPAREN,
    "let" => LET,
    "in" => IN,
    "[" => RBRACKET,
    "]" => LBRACKET,
    "true" => TRUE,
    "false" => FALSE,
    "def" => DEF,
    "," => COMMA,
    "return" => RETURN,

    "val" => VAL,
    "var" => VAR,

    r"[_A-Za-z][_A-Za-z0-9]*" => IDENTIFIER,
    r"[-]?[0-9]+" => NUMBER,
    // TODO FLOATS
    r#""([^\\"]|\\[~ntr\\"])*""# => STRING_LITERAL,
}

pub TopLevel: AST = {
    <toplevel: TopLevelExpressions> => AST::Top(toplevel),
                                    => AST::Top(vec![AST::Expression(Expr::NoneVal)]),
}

TopLevelExpressions: Vec<AST> = {
    <mut elements: (<TopLevelExpression> SEMICOLON)*> <element: TopLevelExpression> SEMICOLON? => {
        elements.push(element);
        elements
    }
}

TopLevelExpression: AST = {
    // FIXME: This permits 'return' in top level
    Statement => <>,
    FunDecl => <>,
}

Statements: Vec<AST> = {
    <mut elements: (<Statement> SEMICOLON)*> <element: Statement> SEMICOLON? => {
        elements.push(element);
        elements
    }
}

// Those are 'top' level expression in block,
// do not put things that can appear in operations
// (ie. in binary operations, conditions and so on...)
// here belongs for example while or for cycle.
Statement: AST = {
    Expr => AST::Expression(<>), // All subexpressions - contains binaryop, ifs, calls and so on.
    Return => <>,
    VarDecl => <>,
    Assignment => <>,
}

Assignment: AST = {
    <name: Identifier> ASSIGN <value: Expr> => AST::AssignVariable { name, value }
}

VarDecl: AST = {
    VAL <name: Identifier> ASSIGN <value: Expr> => AST::Variable { name, mutable: false, value },
    VAR <name: Identifier> ASSIGN <value: Expr> => AST::Variable { name, mutable: true, value },
}

Expr: Expr = {
    <left:Expr> <op:LogicalOp> <right: AExpr> => Expr::Operator{op: op, arguments: vec![left, right]},
    AExpr,
}

AExpr: Expr = {
    <left:AExpr> <op:ExprOp> <right:Factor> => Expr::Operator{op: op, arguments: vec![left, right]},
    Factor,
}

Factor: Expr = {
    <left:Factor> <op:TermOp> <right:Term> => Expr::Operator{op: op, arguments: vec![left, right]},
    Term,
}

Term: Expr = {
    // TODO: floats
    LowPrio => <>,
}

LowPrio: Expr = {
    TRUE => Expr::Bool(true),
    FALSE => Expr::Bool(false),
    Number => <>,
    String => Expr::String(<>),
    Call => <>,
    LPAREN <expr: Expr> RPAREN => expr,
    Block => <>,
    Conditional => <>,
    Identifier => Expr::AccessVariable{name: <>},
}

Call: Expr = {
    <function: Identifier> LPAREN <arguments: Arguments> RPAREN => {
        Expr::CallFunction{ name: function, arguments: arguments }
    }
    // TODO: Method calls over objects, lists, strings and so on.
}

LogicalOp: Opcode = {
    LESS => Opcode::Less,
    LESSEQ => Opcode::LessEq,
    GREATER => Opcode::Greater,
    GREATEREQ => Opcode::GreaterEq,
    EQ => Opcode::Eq,
}

ExprOp: Opcode = {
    PLUS => Opcode::Add,
    MINUS => Opcode::Sub,
}

TermOp: Opcode = {
    MULTIPLY => Opcode::Mul,
    DIVIDE => Opcode::Div,
}

Number: Expr = {
    NUMBER => Expr::Integer(i32::from_str(<>).unwrap()),
}

String: String = {
    <s:STRING_LITERAL> => s[1..s.len()-1].to_string(),
}

Block: Expr = {
    CURLYBOPEN <expressions: Statements> CURLYBCLOSE => Expr::Block(expressions),
    CURLYBOPEN CURLYBCLOSE => Expr::NoneVal,
}

FunDecl: AST = {
    DEF <name: Identifier> <parameters: Parameters> ASSIGN <body: Expr> => {
        AST::Function{name, parameters, body: body}
    }
}

Identifier: String = IDENTIFIER => <>.to_string();

Parameters: Vec<String> = {
    LPAREN <elements: (<Identifier> COMMA)*> <element: Identifier?> RPAREN =>
        match element {
            None => elements,
            Some(e) => { let mut elements = elements; elements.push(e); elements }
        }
}

Arguments: Vec<Expr> = {
    <mut elements: (<Expr> COMMA)*> <element: Expr?> => {
        match element {
            None => elements,
            Some(e) => { elements.push(e); elements }
        }
    }
}

Conditional: Expr = {
    IF <guard: Expr> <then: Block> <els: (ELSE <Block>)?> =>
                    Expr::Conditional{guard: Box::new(guard),
                            then_branch: Box::new(then),
                            else_branch: els.map(Box::new)},
}

Return: AST = {
    RETURN <expr: Expr> => AST::Return(expr)
}
